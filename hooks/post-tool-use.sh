#!/usr/bin/env bash
set -euo pipefail

# Error handling — fail open (exit 0) so we never block the agent
trap 'echo "[ConKeeper] post-tool-use.sh failed at line $LINENO" >&2; exit 0' ERR

# --- Dependencies ---

if ! command -v jq &>/dev/null; then
    exit 0
fi

# --- Parse hook input ---

input=$(cat)
tool_name=$(printf '%s' "$input" | jq -r '.tool_name // empty') || exit 0
session_id=$(printf '%s' "$input" | jq -r '.session_id // empty') || exit 0
cwd=$(printf '%s' "$input" | jq -r '.cwd // empty') || exit 0
# tool_input needs jq -c: it's a JSON object that must be serialized to string
tool_input=$(printf '%s' "$input" | jq -c '.tool_input // empty' 2>/dev/null) || tool_input=""

# Validate session_id (security: prevents path traversal)
if [[ -z "$session_id" ]] || ! [[ "$session_id" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    exit 0
fi

# Resolve cwd to an absolute path (security: prevents path traversal via crafted cwd)
cwd=$(cd "$cwd" 2>/dev/null && pwd) || exit 0

# Require memory directory to exist
[[ -d "$cwd/.claude/memory" ]] || exit 0

# --- Read configuration ---

observation_hook=true
observation_detail="full"

config_file="$cwd/.claude/memory/.memory-config.md"
if [[ -f "$config_file" ]]; then
    # Extract YAML frontmatter (between first two --- lines), strip comments
    frontmatter=$(awk '/^---$/ { if (++n == 2) exit; next } n == 1 { sub(/#.*/, ""); print }' "$config_file")
    if [[ -n "$frontmatter" ]]; then
        val=$(printf '%s' "$frontmatter" | awk -F': *' '$1 == "observation_hook" { gsub(/^[[:space:]]+|[[:space:]]+$/, "", $2); print $2 }')
        [[ -n "$val" ]] && observation_hook="$val"
        val=$(printf '%s' "$frontmatter" | awk -F': *' '$1 == "observation_detail" { gsub(/^[[:space:]]+|[[:space:]]+$/, "", $2); print $2 }')
        [[ -n "$val" ]] && observation_detail="$val"
    fi
fi

# Check if observations are disabled
if [[ "$observation_hook" == "false" ]] || [[ "$observation_detail" == "off" ]]; then
    exit 0
fi

# --- Observation file path ---

obs_dir="$cwd/.claude/memory/sessions"
obs_file="$obs_dir/$(date +%Y-%m-%d)-observations.md"
mkdir -p "$obs_dir"

# Security: refuse to write through symlinks
[[ -L "$obs_file" ]] && exit 0

# Create file header if needed
if [[ ! -f "$obs_file" ]]; then
    printf '# Session Observations — %s\n<!-- Auto-generated by ConKeeper PostToolUse hook -->\n\n' "$(date +%Y-%m-%d)" > "$obs_file"
fi

# --- Classify tool and extract fields ---

timestamp=$(date +%H:%M:%S)

# Action type + stub classification (single case for Bash 3.2 compat)
is_stub=true
case "$tool_name" in
    Read|Glob|Grep)                    action="read" ;;
    Write|Edit|MultiEdit|NotebookEdit) action="write" ;;
    Bash)                              action="execute"; is_stub=false ;;
    WebFetch|WebSearch)                action="fetch";   is_stub=false ;;
    Task)                              action="delegate"; is_stub=false ;;
    *)                                 action="other";   is_stub=false ;;
esac

# When observation_detail is stubs_only, all tools get stub entries
if [[ "$observation_detail" == "stubs_only" ]]; then
    is_stub=true
fi

# Extract file path from tool_input (truncate to 120 chars)
file_path=$(printf '%s' "$tool_input" | jq -r '.file_path // .path // .command // .pattern // "—"' 2>/dev/null | head -c 120) || true
[[ -z "$file_path" ]] && file_path="—"

# --- Build and append entry ---

if [[ "$is_stub" == true ]]; then
    # Stub entry: timestamp | tool | action | path | — | success
    printf -- '- **%s** | `%s` | %s | `%s` | — | success\n' \
        "$timestamp" "$tool_name" "$action" "$file_path" >> "$obs_file"
else
    # Full entry: timestamp | tool | action | path | command_summary | success
    cmd_summary=$(printf '%s' "$tool_input" | jq -r '.command // "—"' 2>/dev/null | head -c 80) || true
    [[ -z "$cmd_summary" ]] && cmd_summary="—"
    printf -- '- **%s** | `%s` | %s | `%s` | `%s` | success\n' \
        "$timestamp" "$tool_name" "$action" "$file_path" "$cmd_summary" >> "$obs_file"
fi

exit 0
