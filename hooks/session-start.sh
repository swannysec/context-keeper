#!/usr/bin/env bash
set -euo pipefail

# Error handling for debugging (MEDIUM-1)
trap 'echo "session-start.sh failed at line $LINENO" >&2' ERR

# Feature blocks in this file:
# 1. Directory validation + config reading
# 2. Observations file creation
# 3. .last-sync first-run creation
# 4. Health scoring (Phase B) — always-on, not budget-gated
# 5. Memory diff (Phase A) — gated by token budget (economy=skip)
# 6. Friction loading (Phase E) — gated by token budget (economy=skip)
# 7. Context building + decision index directive (Phase C)
# 8. JSON output

# Sanitize content for safe embedding in <conkeeper-*> XML blocks.
# Prevents tag injection by escaping closing tags that could break out of the wrapper.
sanitize_context_content() {
    printf '%s' "$1" | sed 's|</conkeeper-|<\\/conkeeper-|g'
}

# Check for memory directories
# NOTE: PROJECT_MEMORY uses relative path - this script assumes CWD is the project root.
# Claude Code invokes hooks from the project directory, so this is the expected behavior.
# (HIGH-3: Documented CWD assumption)
GLOBAL_MEMORY="$HOME/.claude/memory"
PROJECT_MEMORY=".claude/memory"

# Validate directory exists and resolve symlinks safely
# Returns 0 if valid directory, 1 otherwise
validate_memory_dir() {
    local dir="$1"
    local expected_parent="$2"

    # Check if path exists and is a directory (follows symlinks)
    if [ ! -d "$dir" ]; then
        return 1
    fi

    # If it's a symlink, resolve and validate the target
    if [ -L "$dir" ]; then
        local resolved
        # Use readlink -f if available, otherwise basic check
        if command -v readlink &>/dev/null; then
            resolved=$(readlink -f "$dir" 2>/dev/null) || return 1
            # Ensure resolved path is under expected parent (prevent symlink escape)
            # Use path-boundary check: require trailing / or exact match
            case "$resolved" in
                "$expected_parent"/*|"$expected_parent") return 0 ;;
                *) return 1 ;;  # Symlink points outside expected location
            esac
        fi
    fi

    return 0
}

has_global=false
has_project=false

validate_memory_dir "$GLOBAL_MEMORY" "$HOME" && has_global=true
validate_memory_dir "$PROJECT_MEMORY" "$PWD" && has_project=true

# --- Source shared config library ---
SCRIPT_DIR_SS="$(cd "$(dirname "$0")" && pwd)"
. "$SCRIPT_DIR_SS/lib-config.sh"

# --- Read configuration ---
token_budget="standard"
staleness_commits=5
if [ "$has_project" = true ]; then
    if extract_frontmatter ".claude/memory/.memory-config.md"; then
        token_budget=$(parse_yaml_str "token_budget" "standard")
        # Allowlist validation
        case "$token_budget" in
            economy|light|standard|detailed) ;;
            *) token_budget="standard" ;;
        esac
        staleness_commits=$(parse_yaml_int "staleness_commits" "5")
    fi
fi

# Create observations file for this session
if [ "$has_project" = true ]; then
    obs_dir=".claude/memory/sessions"
    obs_file="$obs_dir/$(date +%Y-%m-%d)-observations.md"
    mkdir -p "$obs_dir"
    # Security: refuse to write through symlinks
    if [ ! -L "$obs_file" ] && [ ! -f "$obs_file" ]; then
        printf '# Session Observations — %s\n<!-- Auto-generated by ConKeeper PostToolUse hook -->\n\n' "$(date +%Y-%m-%d)" > "$obs_file"
    fi
fi

# --- .last-sync + Health Scoring + Diff ---
# These blocks append to additional_context which is added after the base context
additional_context=""

if [ "$has_project" = true ]; then
    LAST_SYNC_FILE=".claude/memory/.last-sync"
    MEMORY_FILES="active-context.md progress.md patterns.md glossary.md product-context.md friction.md"
    FLAG_DIR="${TMPDIR:-/tmp}/conkeeper"
    (umask 077; mkdir -p "$FLAG_DIR")
    chmod 700 "$FLAG_DIR" 2>/dev/null || true

    # Check git availability once for health + diff blocks
    in_git_repo=false
    if command -v git &>/dev/null && git rev-parse --git-dir &>/dev/null 2>&1; then
        in_git_repo=true
    fi

    # .last-sync first-run: create marker and skip health+diff this session
    first_run=false
    if [ -L "$LAST_SYNC_FILE" ]; then
        # Security: refuse to read/write through symlinks
        :
    elif [ ! -f "$LAST_SYNC_FILE" ]; then
        printf '%s' "$(date +%s)" > "$LAST_SYNC_FILE"
        first_run=true
    fi

    # --- Health Scoring (Phase B) ---
    if [ "$first_run" = false ] && [ "$staleness_commits" -gt 0 ] && [ ! -L "$LAST_SYNC_FILE" ] && [ -f "$LAST_SYNC_FILE" ]; then
        health_cache="$FLAG_DIR/health-$(date +%Y%m%d)"
        # Clean up old health caches (older than 7 days)
        find "$FLAG_DIR" -name 'health-*' -mtime +7 -delete 2>/dev/null || true
        stale_list=""
        health_start=$(date +%s)

        # Only run health check if git is available and we're in a repo
        if [ "$in_git_repo" = true ]; then
            for mfile in $MEMORY_FILES; do
                mpath=".claude/memory/$mfile"
                if [ -f "$mpath" ] && [ ! -L "$mpath" ]; then
                    # Get mtime (BSD stat)
                    file_mtime=$(stat -f %m "$mpath" 2>/dev/null) || continue
                    # Count commits since file mtime (scoped to entire repo — intentional;
                    # more commits = more likely memory is out of date regardless of which files changed)
                    commit_count=$(git rev-list --count --after="@${file_mtime}" HEAD -- . 2>/dev/null) || continue
                    if [ "$commit_count" -gt "$staleness_commits" ]; then
                        if [ -n "$stale_list" ]; then
                            stale_list="${stale_list}
  - ${mfile} (${commit_count} commits behind)"
                        else
                            stale_list="  - ${mfile} (${commit_count} commits behind)"
                        fi
                    fi
                fi
                # Performance guard: skip remaining if >1s elapsed
                health_now=$(date +%s)
                if [ $((health_now - health_start)) -gt 1 ]; then
                    stale_list="${stale_list}
  (health check timed out — partial results)"
                    break
                fi
            done
        fi

        # Cache results for stop hook
        if [ -n "$stale_list" ]; then
            printf '%s' "$stale_list" > "$health_cache"
            additional_context="${additional_context}
<conkeeper-health>
Stale memory (>${staleness_commits} commits since last update):
${stale_list}
Before proceeding with the user's task, run /memory-sync to refresh stale memory files.
</conkeeper-health>"
        fi
    fi

    # --- Memory Diff (Phase A) ---
    if [ "$first_run" = false ] && [ "$token_budget" != "economy" ] && [ ! -L "$LAST_SYNC_FILE" ] && [ -f "$LAST_SYNC_FILE" ]; then
        last_sync_epoch=$(head -c 20 "$LAST_SYNC_FILE" 2>/dev/null)
        # Validate epoch is numeric and not in the future (overflow protection)
        current_epoch=$(date +%s)
        if ! printf '%s' "$last_sync_epoch" | grep -qE '^[0-9]+$'; then
            : # invalid epoch — skip diff silently
        elif [ "$last_sync_epoch" -gt "$current_epoch" ]; then
            echo "[ConKeeper] Warning: .last-sync timestamp is in the future, skipping diff" >&2
        else
            # Determine max commits by budget
            case "$token_budget" in
                light) max_commits=3 ;;
                standard) max_commits=5 ;;
                detailed) max_commits=10 ;;
                *) max_commits=5 ;;
            esac

            diff_commits=""
            diff_memory=""
            total_commits=0

            # Git commits since last sync
            if [ "$in_git_repo" = true ]; then
                all_commits=$(git log --oneline --no-decorate --after="@${last_sync_epoch}" -- . 2>/dev/null) || true
                if [ -n "$all_commits" ]; then
                    total_commits=$(printf '%s\n' "$all_commits" | wc -l | tr -d ' ')
                    shown_commits=$(sanitize_context_content "$(printf '%s\n' "$all_commits" | head -n "$max_commits" | awk '{printf "%s%s", sep, $0; sep=" | "}')")
                    diff_commits="  repo: ${shown_commits}"
                    if [ "$total_commits" -gt "$max_commits" ]; then
                        remaining=$((total_commits - max_commits))
                        diff_commits="${diff_commits} (+${remaining} more)"
                    fi
                fi
            fi

            # Memory file changes since last sync
            changed_files=""
            for mfile in $MEMORY_FILES; do
                mpath=".claude/memory/$mfile"
                if [ -f "$mpath" ] && [ ! -L "$mpath" ]; then
                    file_mtime=$(stat -f %m "$mpath" 2>/dev/null) || continue
                    if [ "$file_mtime" -gt "$last_sync_epoch" ]; then
                        if [ -n "$changed_files" ]; then
                            changed_files="${changed_files}, ${mfile} modified"
                        else
                            changed_files="${mfile} modified"
                        fi
                    fi
                fi
            done

            # Check decisions/ for new/modified ADRs
            if [ -d ".claude/memory/decisions" ]; then
                for adr in .claude/memory/decisions/*.md; do
                    [ -f "$adr" ] || continue
                    [ -L "$adr" ] && continue
                    adr_name=$(basename "$adr")
                    [ "$adr_name" = "INDEX.md" ] && continue
                    adr_mtime=$(stat -f %m "$adr" 2>/dev/null) || continue
                    if [ "$adr_mtime" -gt "$last_sync_epoch" ]; then
                        if [ -n "$changed_files" ]; then
                            changed_files="${changed_files}, decisions/${adr_name} modified"
                        else
                            changed_files="decisions/${adr_name} modified"
                        fi
                    fi
                done
            fi

            if [ -n "$changed_files" ]; then
                diff_memory="  memory: ${changed_files}"
            fi

            # Build diff block if anything changed
            if [ -n "$diff_commits" ] || [ -n "$diff_memory" ]; then
                diff_output="<conkeeper-diff>
Since last sync (${total_commits} commits):"
                if [ -n "$diff_commits" ]; then
                    diff_output="${diff_output}
${diff_commits}"
                fi
                if [ -n "$diff_memory" ]; then
                    diff_output="${diff_output}
${diff_memory}"
                fi
                diff_output="${diff_output}
Read the updated memory files listed above before proceeding with any task.
</conkeeper-diff>"
                additional_context="${additional_context}
${diff_output}"
            fi
        fi
    fi
fi

# --- Friction-Aware Loading (Phase E) ---
if [ "$has_project" = true ] && [ "$token_budget" != "economy" ]; then
    friction_file=".claude/memory/friction.md"
    if [ -f "$friction_file" ] && [ ! -L "$friction_file" ]; then
        friction_content=""
        case "$token_budget" in
            light)
                friction_content=$(head -c 800 "$friction_file" 2>/dev/null) || true
                ;;
            standard)
                friction_content=$(head -c 1600 "$friction_file" 2>/dev/null) || true
                ;;
            detailed|*)
                friction_content=$(cat "$friction_file" 2>/dev/null) || true
                ;;
        esac
        if [ -n "$friction_content" ]; then
            friction_content=$(sanitize_context_content "$friction_content")
            additional_context="${additional_context}
<conkeeper-friction>
${friction_content}
</conkeeper-friction>"
        fi
    fi
fi

# Build context message
context=""

if [ "$has_global" = true ] || [ "$has_project" = true ]; then
    context="<memory-system-active>
Memory system detected.
- Global memory: $([ "$has_global" = true ] && echo "\$HOME/.claude/memory" || echo "not configured")
- Project memory: $([ "$has_project" = true ] && echo ".claude/memory" || echo "not configured")

For non-trivial tasks, load relevant memory before starting work:
- Read product-context.md and active-context.md for project context
- Check progress.md for task status
- Review decisions/ for architectural context
- Search memory with /memory-search <query> before re-investigating known problems

Update memory when:
- Making significant architectural decisions (add to decisions/)
- Completing or starting major tasks (update progress.md)
- Context changes significantly (update active-context.md)
- Session ends with important state to preserve

To initialize memory for a new project: /memory-init
To sync current session to memory: /memory-sync
To run session retrospection: /memory-reflect
A decision index is available at decisions/INDEX.md. Use it as a lookup table — do not read every ADR file.
</memory-system-active>"
else
    context="<memory-system-available>
No memory directories detected. For organized project work, initialize memory with /memory-init.
This provides structured context management across sessions.
</memory-system-available>"
fi

# Append additional context (health, diff, etc.)
if [ -n "$additional_context" ]; then
    context="${context}${additional_context}"
fi

# JSON encoding function (CRITICAL-1, HIGH-1)
# Uses jq if available, otherwise falls back to pure-bash encoding
json_encode() {
    local input="$1"
    if command -v jq &>/dev/null; then
        # jq handles all JSON escaping correctly
        printf '%s' "$input" | jq -Rs '.'
    else
        # Pure-bash fallback: escape backslashes, quotes, and control characters
        # Preserves newlines as \n escape sequences for proper JSON
        local escaped="$input"
        escaped="${escaped//\\/\\\\}"      # Escape backslashes first
        escaped="${escaped//\"/\\\"}"      # Escape double quotes
        escaped="${escaped//$'\t'/\\t}"    # Escape tabs
        escaped="${escaped//$'\r'/\\r}"    # Escape carriage returns
        escaped="${escaped//$'\n'/\\n}"    # Escape newlines as \n
        # Strip remaining control chars (U+0000-U+001F except handled above)
        escaped=$(printf '%s' "$escaped" | tr -d '\000-\010\013\014\016-\037')
        printf '"%s"' "$escaped"
    fi
}

# Output JSON with properly encoded context
encoded_context=$(json_encode "$context")

cat <<EOF
{
  "hookSpecificOutput": {
    "hookEventName": "SessionStart",
    "additionalContext": $encoded_context
  }
}
EOF
